---
layout: post
title: The RDP as I understand it
permalink: /RDP/
---

---

#### Table of contents

- [Welcoming notes](#welcoming-notes)
- [Overview](#overview)
- [Memory](#memory)
  - [Coverage](#coverage)
    - [color\_on\_cvg](#color_on_cvg)
  - [Depth](#depth)
    - [Opaque](#opaque)
    - [Interpenetrating](#interpenetrating)
    - [Transparent](#transparent)
    - [Decal](#decal)
- [Rasterizer](#rasterizer)
- [Color Combiner](#color-combiner)
- [Blender](#blender)
  - [Video filter](#video-filter)
- [Texture Engine](#texture-engine)
- [Texture Filter](#texture-filter)
- [References and more reading on the RDP](#references-and-more-reading-on-the-rdp)

---

## Welcoming notes

In the N64 emudev scene, RDP emulation is usually skipped entirely. This is because there are tested and accurate RDP plugins (namely [Angrylion](https://github.dev/ata4/angrylion-rdp-plus) and [paraLLEl-RDP](https://github.com/Themaister/parallel-rdp)) that you can seamlessly integrate into your emulator with little work to get an almost perfect RDP implementation immediately.

Along with this fact, the documentation on the N64 ~~is~~ was few and far between, especially if you didn't know where to look. It has been getting better lately with the introduction of n64brew.

On top of that, the RDP is not easy to emulate compared to say the PS1 GPU. Weird triangles, many different little modes to handle, and lack of documentation outside of the programmers manual contribute to this.

All of these facts above lead to many N64 developers not even attempting the RDP, or quitting too early. And truth be told your RDP is most likely not going to surpass Angrylion in accuracy. But if you're like me and your main goal in emudev is fun & learning, then the following documentation is for you.

**Disclaimer: This is my ongoing documentation on the RDP as I understand it. The following contents may be completely wrong on some things. Please let me know of any mistakes by [opening an issue](https://github.com/OFFTKP/offtkp.github.io/issues)**

Now with that being said, thanks for reading! Good luck in your RDP endeavors! :)

## Overview

The RDP or Reality Display Processor is essentially the GPU of the Nintendo 64. It was quite revolutionary for its time, but
had its weaknesses which made game development harder. On a low level, it works by preparing a command list in RDRAM or RSPs DMEM.
On a high level however, game developers would use ready-made RSP microcode functions that would translate vertices into what the RDP
uses, which is slopes. The rest of this post is going to focus on the low level stuff.

The RDP has 4 modes:
- 1 cycle
- 2 cycle
- copy
- fill

Fill mode is the simplest, but all it does is output a simple fill color (configured by the SetFillColor RDP command).
This mode is good for filling the framebuffer with a specific color or clearing the depth buffer.
Its theoretical peak performance is four 16 bit pixels or two 32 bit pixels.

Copy mode is the second simplest, and it is used for fast image to image copies. If you don't
care about stuff like depth testing or the color combiner or the blender and you just want to copy
a texture to the framebuffer, this mode is for you.

Then there's 1 cycle and 2 cycle modes. We're going to look at 1 cycle mode first.

| ![rdp_1cycle.gif]({{ site.baseurl }}/assets/images/rdp_1cycle.gif) | 
|:--:| 
| *1 cycle pipeline* |

There's 6 stages:

- **RS** (Rasterizer): Generates pixel attributes such as position, depth, rgba color, uvs, and coverage value.
- **TX** (Texture Engine): Fetches 4 texels nearest to the pixel.
- **TF** (Texture Filter): Combines the 4 texels into 1 bilinear-filtered texel.
- **CC** (Color Combiner): Combines colors. This can be the texel color previously generated and the stepped rgba color from the rasterizer but it doesn't have to be.
- **BL** (Blender): Also combines colors. The blender has access to the framebuffer color (which the CC doesn't) and can also perform fog operations.
- **MI** (Memory Interface): An interface to the framebuffer memory. It has pointers to the framebuffer and the depth buffer.

These stages will be further explained below.

The 2 cycle mode simply does everything (except rasterization) twice:

| ![rdp_2cycle.gif]({{ site.baseurl }}/assets/images/rdp_2cycle.gif) | 
|:--:|
| *2 cycle pipeline* |

Having 2 of each pipeline phase means the 2 cycle mode has more capabilities (fog, mipmapping, chroma keying and others) but produces 1 pixel per 2 cycles (theoretical peak) while the 1 cycle mode produces 1 pixel per cycle.

---

## Memory

Memory Interface is the last step of the pipeline but first understanding the memory architecture is important.

First we need to understand the format of the framebuffer and depth buffer.

| ![rdp_mem_format.gif]({{ site.baseurl }}/assets/images/rdp_mem_format.gif) |
|:--:|
| *Memory format - keep in mind RDRAM has 9 bit bytes* |

(In 32bpp, the upper 3 bits of alpha channel are the coverage and the rest are not used)


### Coverage

In the framebuffer, the alpha channel is used to store the coverage value.

Coverage is essentially a value that denotes how much a pixel is covered by the subpixels. Coverage can be used by the blender for antialiasing, edges of a primitive will have a lower coverage than the area of the primitive (which would have a full coverage value).

Since we have 3 bits to work with and actual pixel coverage ranges from 1-15, a mask (0xa5a5, looks like a checkerboard) is used to take into account only half of the pixels subpixels, thus coverage values range from 1-8 (but stored as 0-7 in binary).

How this coverage is written can be configured using the `SetOtherModes` command. For example you can make some primitives write full coverage to the framebuffer for every pixel (Zap), or make some not change the previous coverage (Save).

#### color_on_cvg

There's also the `color_on_cvg` mode that can be set using `SetOtherModes`. This makes it so that a pixel is only written if the current coverage added to the previous coverage is greater or equal to 8. This helps minimize errors when blending transparent triangles together. For example, Peach when she fades out:

| ![rdp_peach.png]({{ site.baseurl }}/assets/images/rdp_peach.png) |
|:--:|
| *Peach fading out with no color_on_cvg implementation* |

You can clearly see the edges of the triangles in the above image. This is because the edges here have a low coverage value, which would not otherwise be greater or equal to 8 when added to the previous coverage, so those pixels would not be written to the framebuffer.

### Depth

The [depth buffer](https://en.wikipedia.org/wiki/Z-buffering) is an area in memory specified using the `SetZImage` command. Whether depth testing is enabled is configured through `z_compare_en` and whether the depth buffer is updated is configured through `z_update_en` in the `SetOtherModes` command.

The 14 z bits are not actually the depth value, but a compressed version of the depth value, which is then decompressed to an 18 bit (15.3 fixed format) depth value. I would explain how they are compressed but [this post by Kieron]({{ site.baseurl }}/assets/other/z_format.txt) does a great job.

After compression that leaves us with 4 extra bits, which is used for the DeltaZ value. The DeltaZ value is important in determining if a pixel is part of the same surface that is stored in memory.

This is how DeltaZ is computed:    
$$DzPix= \left|DzDx\right| + \left|DzDy\right|$$

To fit it in the 4 bits, another compression algorithm is used, this one is much simpler:    
$$DzMem=\log_2(DzPix)$$

Obviously decompression is the inverse:    
$$DzMem_{Decompressed}=2^{DzMem}$$

When computing whether the pixel is part of the surface, the worst case DeltaZ is used:    
$$DzMax=\max(DzPix, DzMem)$$

There's 4 depth testing modes, configured through the `SetOtherModes` command:

#### Opaque

This mode does a simple `NewZ < OldZ` usually. However if coverage overflows it does a different check called "Nearer" (mentioned in "Z Calculation" chapter in the N64 programming manual)

$$Nearer=(NewZ - DzMax) \le OldZ$$

This check is to reduce punchtrough when the new triangle is not part of the previous surface.

| ![rdp_opaque.png]({{ site.baseurl }}/assets/images/rdp_opaque.png) |
|:--:|
| *Edges of triangles look weird<br>without a correct opaque implementation* |

#### Interpenetrating

TODO: explain

#### Transparent

This is used for transparent surfaces (think water outside of Peachs castle). This is usually used in conjuction with color_on_cvg to avoid internal edges blending twice as mentioned earlier.
The check for this is by far the easiest to implement. If `NewZ < OldZ`, it passes the depth test.

#### Decal

This mode is used to render a textured primitive on top of another surface (think a flag for example). This depth test passes when the primitive we are trying to render is coplanar with the surface we are trying to render it on top of. TODO: explain how this is checked

| ![rdp_tree.png]({{ site.baseurl }}/assets/images/rdp_tree.png) |
|:--:|
| *Tree shadow without a<br>correct decal implementation* |

---

## Rasterizer

The rasterizer uses an edgewalker algorithm to step the primitive slopes and the property (rgba, stw, z) slopes. If you want a peek into a basic implementation and further explanation of how it works, [check out my other post on N64 triangles]({{ site.baseurl }}/Trongle/).
Note that the implementation on that post only steps the primitive itself, not the properties, and does not implement other important things like subpixels and scissoring.

---

## Color Combiner

The color combiner can combine 4 colors into 1, using the equation (A - B) * C + D.
A, B, C and D can be many different things, and they are configured by the `SetOtherModes` command.

| ![rdp_mem_format.gif]({{ site.baseurl }}/assets/images/rdp_cc.gif) | 
|:--:| 
| *How the color combiner picks colors* |

There's also an alpha combiner, which uses the same equation but different inputs:

| ![rdp_mem_format.gif]({{ site.baseurl }}/assets/images/rdp_ac.gif) | 
|:--:| 
| *How the alpha combiner picks colors* |

Using the color combiner you can (for example) combine texel colors with shade colors, to produce a shaded texture.

The color combiner also has 2 configurable colors, primitive color and environment color, configured through the `SetPrimitiveColor`/`SetEnvironmentColor` respectively.
Traditionally they are used to set a constant polygon face color or the ambient environment color, but technically the names are arbitrary and they can be used for any purpose

---

## Blender

The blender blends the previously combined color with the framebuffer color or the blend register color (set by `SetBlendColor`) or the fog color.

There's 4 inputs, named p, a, m, b in the manual but let's name them color 1, multiplier 1, color 2 and multiplier 2. These inputs are specified by the `SetOtherModes` command and are different for cycle 1 and 2.

Color 1 and 2 are picked from the following table:

| Index | Source |
|:--:|:--:|
| 0 | Combined color |
| 1 | Framebuffer color |
| 2 | Blend color |
| 3 | Fog color |

Multiplier 1 is picked from this table:

| Index | Source |
|:--:|:--:|
| 0 | Combined alpha |
| 1 | Fog alpha |
| 2 | Shade alpha |
| 3 | 0.0 |

Multiplier 2 is picked from this table:

| Index | Source |
|:--:|:--:|
| 0 | Inverse multiplier 1 |
| 1 | Memory coverage |
| 2 | 1.0 |
| 3 | 0.0 |

The blender output is calculated like so:    

$$BlenderOutput = \frac{p\cdot a + m \cdot b}{a+b}$$

The alpha channel is not stored (as it doesn't matter) and as we know the alpha channel is used to store coverage instead.

### Video filter

Before the blender output is written, if the pixel is not fully covered the video filter algorithm is applied:    

$$FinalColor=cvg \cdot BlenderOutput+(1.0-cvg)\cdot BackgroundColor$$

$$BackgroundColor$$ is a combination of the fully covered pixels in a $$5x3$$ area around the current pixel

---

## Texture Engine
TODO

---

## Texture Filter
TODO

## References and more reading on the RDP
- N64 programmers manual
- SGI RDP command summary
- [Z format encoding explanation]({{ site.baseurl }}/assets/other/z_format.txt) by Kieron
- Angrylion & paraLLEl-RDP source code
- [n64-resources repository](https://github.com/Dillonb/n64-resources) by Dillon
- [n64brew](https://n64brew.dev/wiki/Main_Page)
