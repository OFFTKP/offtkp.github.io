---
layout: post
title: The RDP as I understand it
permalink: /RDP/
---

*This is my ongoing documentation on the RDP as I understand it. The following contents may be completely wrong on some things.*

*TODO: replace some names with anchors (#Blender etc.)*

## Overview

The RDP or Reality Display Processor is essentially the GPU of the Nintendo 64. It was quite revolutionary for its time, but
had its weaknesses which made game development harder. On a low level, it works by preparing a command list in RDRAM or RSPs DMEM.
On a high level however, game developers would use ready-made RSP microcode functions that would translate vertices into what the RDP
uses, which is slopes. The rest of this post is going to focus on the low level stuff.

The RDP has 4 modes:
- 1 cycle
- 2 cycle
- copy
- fill

Fill mode is the simplest, but all it does is output a simple fill color (configured by the SetFillColor RDP command).
This mode is good for filling the framebuffer with a specific color or clearing the depth buffer.
Its theoretical peak performance is four 16 bit pixels or two 32 bit pixels.

Copy mode is the second simplest, and it is used for fast image to image copies. If you don't
care about stuff like depth testing or the color combiner or the blender and you just want to copy
a texture to the framebuffer, this mode is for you.

Then there's 1 cycle and 2 cycle modes. We're going to look at 1 cycle mode first.

| ![rdp_1cycle.gif]({{ site.baseurl }}/assets/images/rdp_1cycle.gif) | 
|:--:| 
| *1 cycle pipeline* |

There's 6 stages:

- **RS** (Rasterizer): Generates pixel attributes such as position, depth, rgba color, uvs, and coverage value.
- **TX** (Texture Engine): Fetches 4 texels nearest to the pixel.
- **TF** (Texture Filter): Combines the 4 texels into 1 bilinear-filtered texel.
- **CC** (Color Combiner): Combines colors. This can be the texel color previously generated and the stepped rgba color from the rasterizer but it doesn't have to be.
- **BL** (Blender): Also combines colors. The blender has access to the framebuffer color (which the CC doesn't) and can also perform fog operations.
- **MI** (Memory Interface): An interface to the framebuffer memory. It has pointers to the framebuffer and the depth buffer.

These stages will be further explained below.

The 2 cycle mode simply does everything (except rasterization) twice:

| ![rdp_2cycle.gif]({{ site.baseurl }}/assets/images/rdp_2cycle.gif) | 
|:--:| 
| *2 cycle pipeline* |

Having 2 of each pipeline phase means the 2 cycle mode has more capabilities (fog, mipmapping, chroma keying and others) but produces 1 pixel per 2 cycles (theoretical peak) while the 1 cycle mode produces 1 pixel per cycle.

## Memory

First we need to understand the format of the framebuffer and depth buffer. The following are for 16 bpp:

| ![rdp_mem_format.gif]({{ site.baseurl }}/assets/images/rdp_mem_format.gif) | 
|:--:| 
| *Memory format* |

Since RDRAM has 9 bit bytes, we have access to 18 bits for 2 bytes. In our 16 bpp framebuffer, 15 bits are used for the R G and B values, and 3 bits for coverage.

##### Coverage

A pixel in the RDP is actually a 4x4 array of subpixels. This is why the rectangle/triangle command parameters that specify positions are in fixed point format (for example, the FillRectangle commands YH/YL/XH/XL are all 10.2 fixed point format, the fractional part used to specify which subpixel we're at).

Coverage is essentially a value that denotes how much a pixel is covered by the subpixels. Coverage can be used by the blender for antialiasing, edges of a primitive will have a lower coverage than the area of the primitive (which would have a full coverage value).

Since we have 3 bits to work with and actual pixel coverage ranges from 1-15, a mask (0xa5a5, looks like a checkerboard) is used to take into account only half of the pixels subpixels, thus coverage values range from 1-8 (but stored as 0-7 in binary).

How this coverage is written can be configured using the SetOtherModes command. For example you can make some primitives write full coverage to the framebuffer for every pixel, or make some not change the previous coverage.

##### Depth
The 14 z bits are not actually the depth value, but a compressed version of the depth value, which is then decompressed to an 18 bit (15.3 fixed format) depth value. I would explain how they are compressed but [this post by Kieron]({{ site.baseurl }}/assets/other/z_format.txt) does a great job.

## Rasterizer

The rasterizer uses an edgewalker algorithm to step the primitive slopes and the property (rgba, stw, z) slopes. If you want a peek into a basic implementation and further explanation of how it works, [check out my other post on N64 triangles]({{ site.baseurl }}/Trongle/).
Note that the implementation on that post only steps the primitive itself, not the properties, and does not implement other important things like subpixels and scissoring.

## Color Combiner
The color combiner can combine 4 colors into 1, using the equation (A - B) * C + D.
A, B, C and D can be many different things, and they are configured by the SetOtherModes command.


| ![rdp_mem_format.gif]({{ site.baseurl }}/assets/images/rdp_cc.gif) | 
|:--:| 
| *How the color combiner picks colors* |

There's also an alpha combiner, which uses the same equation but different inputs:

| ![rdp_mem_format.gif]({{ site.baseurl }}/assets/images/rdp_ac.gif) | 
|:--:| 
| *How the alpha combiner picks colors* |

Using the color combiner you can (for example) combine texel colors with shade colors, to produce a shaded texture.

The color combiner also has 2 configurable colors, primitive color and environment color, configured through the SetPrimitive/EnvironmentColor respectively.
Traditionally they are used to set a constant polygon face color or the ambient environment color, but technically the names are arbitrary and they can be used for any purpose

## Blender
The blender blends the previously combined color with the framebuffer color or the blend register color (set by SetBlendColor) or the fog color.

## Texture Engine
TODO

## Texture Filter
TODO