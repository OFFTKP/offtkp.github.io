---
layout: post
title: The RDP as I understand it
permalink: /RDP/
---

*Disclaimer: This is my ongoing documentation on the RDP as I understand it. The following contents may be completely wrong on some things.*

#### Table of contents
- [Overview](#overview)
- [Memory](#memory)
    - [Coverage](#coverage)
    - [Depth](#depth)
      - [Opaque](#opaque)
      - [Interpenetrating](#interpenetrating)
      - [Transparent](#transparent)
      - [Decal](#decal)
- [Rasterizer](#rasterizer)
- [Color Combiner](#color-combiner)
- [Blender](#blender)
- [Texture Engine](#texture-engine)
- [Texture Filter](#texture-filter)

## Overview

The RDP or Reality Display Processor is essentially the GPU of the Nintendo 64. It was quite revolutionary for its time, but
had its weaknesses which made game development harder. On a low level, it works by preparing a command list in RDRAM or RSPs DMEM.
On a high level however, game developers would use ready-made RSP microcode functions that would translate vertices into what the RDP
uses, which is slopes. The rest of this post is going to focus on the low level stuff.

The RDP has 4 modes:
- 1 cycle
- 2 cycle
- copy
- fill

Fill mode is the simplest, but all it does is output a simple fill color (configured by the SetFillColor RDP command).
This mode is good for filling the framebuffer with a specific color or clearing the depth buffer.
Its theoretical peak performance is four 16 bit pixels or two 32 bit pixels.

Copy mode is the second simplest, and it is used for fast image to image copies. If you don't
care about stuff like depth testing or the color combiner or the blender and you just want to copy
a texture to the framebuffer, this mode is for you.

Then there's 1 cycle and 2 cycle modes. We're going to look at 1 cycle mode first.

| ![rdp_1cycle.gif]({{ site.baseurl }}/assets/images/rdp_1cycle.gif) | 
|:--:| 
| *1 cycle pipeline* |

There's 6 stages:

- **RS** (Rasterizer): Generates pixel attributes such as position, depth, rgba color, uvs, and coverage value.
- **TX** (Texture Engine): Fetches 4 texels nearest to the pixel.
- **TF** (Texture Filter): Combines the 4 texels into 1 bilinear-filtered texel.
- **CC** (Color Combiner): Combines colors. This can be the texel color previously generated and the stepped rgba color from the rasterizer but it doesn't have to be.
- **BL** (Blender): Also combines colors. The blender has access to the framebuffer color (which the CC doesn't) and can also perform fog operations.
- **MI** (Memory Interface): An interface to the framebuffer memory. It has pointers to the framebuffer and the depth buffer.

These stages will be further explained below.

The 2 cycle mode simply does everything (except rasterization) twice:

| ![rdp_2cycle.gif]({{ site.baseurl }}/assets/images/rdp_2cycle.gif) | 
|:--:|
| *2 cycle pipeline* |

Having 2 of each pipeline phase means the 2 cycle mode has more capabilities (fog, mipmapping, chroma keying and others) but produces 1 pixel per 2 cycles (theoretical peak) while the 1 cycle mode produces 1 pixel per cycle.

## Memory

First we need to understand the format of the framebuffer and depth buffer. The following are for 16 bpp:

| ![rdp_mem_format.gif]({{ site.baseurl }}/assets/images/rdp_mem_format.gif) |
|:--:|
| *Memory format* |

(In 32bpp, the upper 3 bits of alpha are the coverage and the rest are not used)

Since RDRAM has 9 bit bytes, we have access to 18 bits for 2 bytes. In our 16 bpp framebuffer, 15 bits are used for the R G and B values, and 3 bits for coverage.

#### Coverage

In the framebuffer, the alpha channel is used to store the coverage value.

Coverage is essentially a value that denotes how much a pixel is covered by the subpixels. Coverage can be used by the blender for antialiasing, edges of a primitive will have a lower coverage than the area of the primitive (which would have a full coverage value).

Since we have 3 bits to work with and actual pixel coverage ranges from 1-15, a mask (0xa5a5, looks like a checkerboard) is used to take into account only half of the pixels subpixels, thus coverage values range from 1-8 (but stored as 0-7 in binary).

How this coverage is written can be configured using the SetOtherModes command. For example you can make some primitives write full coverage to the framebuffer for every pixel (Zap), or make some not change the previous coverage (Save).

There's also the `color_on_cvg` mode that can be set using SetOtherModes. This makes it so that a pixel is only written if the current coverage added to the previous coverage is greater or equal to 8. This helps minimize errors when blending transparent triangles together. For example, Peach when she fades out:

| ![rdp_peach.png]({{ site.baseurl }}/assets/images/rdp_peach.png) |
|:--:|
| *Peach fading out with no color_on_cvg implementation* |

You can clearly see the edges of the triangles in the above image. This is because the edges here have a low coverage value, which would not otherwise be greater or equal to 8 when added to the previous coverage, so those pixels would not be written to the framebuffer.

#### Depth
The 14 z bits are not actually the depth value, but a compressed version of the depth value, which is then decompressed to an 18 bit (15.3 fixed format) depth value. I would explain how they are compressed but [this post by Kieron]({{ site.baseurl }}/assets/other/z_format.txt) does a great job.

After compression that leaves us with 4 extra bits, which is the `dz` value or DeltaZ. The DeltaZ value is important in determining if a pixel is part of the same surface that is stored in memory.

This is how DeltaZ is computed:
$$DzPix= \left|DzDx\right| + \left|DzDy\right|$$

To fit it in the 4 bits, another compression algorithm is used, this one is much simpler:
$$DzMem=\log_2(DzPix)$$

Obviously decompression is the inverse:
$$DzMem_{Decompressed}=2^{DzMem}$$

When computing whether the pixel is part of the surface, the worst case DeltaZ is used:
$$DzMax=\max(DzPix, DzMem)$$

There's 4 depth testing modes:

##### Opaque
This mode does a simple `new_z < old_z` usually. However if coverage overflows it does a different check called "Nearer" (mentioned in "Z Calculation" chapter in the N64 programming manual)

$$Nearer=(NewZ - DzMax) \le OldZ$$

This check is to reduce punchtrough when the new triangle is not part of the previous surface.

| ![rdp_opaque.png]({{ site.baseurl }}/assets/images/rdp_opaque.png) |
|:--:|
| *Edges of triangles might look weird without a correct opaque implementation* |

##### Interpenetrating
TODO: explain

##### Transparent
This is used for transparent surfaces (think water outside of Peachs castle). This is usually used in conjuction with color_on_cvg to avoid internal edges blending twice as mentioned earlier.
The check for this is by far the easiest to implement. If `new_z < old_z`, it passes the depth test.

##### Decal
This is (usually) used to render a textured triangle on top of another surface (think a flag for example). This depth test passes when the primitive we are trying to render is coplanar with the surface we are trying to render it on top of. TODO: explain how this is checked

| ![rdp_tree.png]({{ site.baseurl }}/assets/images/rdp_tree.png) |
|:--:|
| *Tree shadow without a correct decal implementation* |

Nit: Every depth testing mode except for Decal also passes if `new_z == 0x3ffff`.


## Rasterizer

The rasterizer uses an edgewalker algorithm to step the primitive slopes and the property (rgba, stw, z) slopes. If you want a peek into a basic implementation and further explanation of how it works, [check out my other post on N64 triangles]({{ site.baseurl }}/Trongle/).
Note that the implementation on that post only steps the primitive itself, not the properties, and does not implement other important things like subpixels and scissoring.

## Color Combiner
The color combiner can combine 4 colors into 1, using the equation (A - B) * C + D.
A, B, C and D can be many different things, and they are configured by the SetOtherModes command.

| ![rdp_mem_format.gif]({{ site.baseurl }}/assets/images/rdp_cc.gif) | 
|:--:| 
| *How the color combiner picks colors* |

There's also an alpha combiner, which uses the same equation but different inputs:

| ![rdp_mem_format.gif]({{ site.baseurl }}/assets/images/rdp_ac.gif) | 
|:--:| 
| *How the alpha combiner picks colors* |

Using the color combiner you can (for example) combine texel colors with shade colors, to produce a shaded texture.

The color combiner also has 2 configurable colors, primitive color and environment color, configured through the SetPrimitiveColor/SetEnvironmentColor respectively.
Traditionally they are used to set a constant polygon face color or the ambient environment color, but technically the names are arbitrary and they can be used for any purpose

## Blender
The blender blends the previously combined color with the framebuffer color or the blend register color (set by SetBlendColor) or the fog color.

## Texture Engine
TODO

## Texture Filter
TODO